import { ExportType } from "~/constants";
import { SurrealInfoDB, SurrealInfoTB } from "~/typings/surreal";
import { getActiveSurreal } from "./connection";
import { fork } from "radash";

/**
 * Export the database schema and save it to a file
 * 
 * TODO Move this logic to Rust
 */
export async function createDatabaseExport(types: ExportType[]) {
	const surreal = getActiveSurreal();
	const dbResponse = await surreal.querySingle("INFO FOR DB");
	const result = dbResponse[0].result as SurrealInfoDB;

	const dbTables = Object.entries(result.tables);
	const dbParams = Object.values(result.params);
	const dbAnalyzers = Object.values(result.analyzers);
	const dbFunctions = Object.values(result.functions);
	const dbScopes = Object.values(result.scopes);

	const output: string[] = [];

	function pushSection(title: string) {
		output.push("", "-- ------------------------------", "-- " + title, "-- ------------------------------", "");
	}

	pushSection('-- Export generated by Surrealist on ' + new Date().toISOString());

	// Define options
	pushSection("OPTION");

	output.push("OPTION IMPORT;");
	
	// Include analyzers
	if (types.includes('analyzers') && dbAnalyzers.length > 0) {
		pushSection("ANALYZERS");

		for (const analyzerDef of dbAnalyzers) {
			output.push(`${analyzerDef};`);
		}
	}

	// Include functions
	if (types.includes('functions') && dbFunctions.length > 0) {
		pushSection("FUNCTIONS");

		for (const funcDef of dbFunctions) {
			output.push(`${funcDef};`);
		}
	}

	// Include params
	if (types.includes('params') && dbParams.length > 0) {
		pushSection("PARAMS");

		for (const paramDef of dbParams) {
			output.push(`${paramDef};`);
		}
	}

	// Include scopes
	if (types.includes('scopes') && dbScopes.length > 0) {
		pushSection("SCOPES");

		for (const scopeDef of dbScopes) {
			output.push(`${scopeDef};`);
		}
	}

	// Include table schemas
	if (types.includes('tables')) {
		for (const [tableName, definition] of dbTables) {
			pushSection(`TABLE: ${tableName}`);
	
			output.push(`${definition};`);
	
			const tbResponse = await surreal.querySingle(`INFO FOR TABLE ${tableName}`);
			const tbInfo = tbResponse[0].result as SurrealInfoTB;
	
			const tbFields = Object.values(tbInfo.fields);
			const tbIndexes = Object.values(tbInfo.indexes);
			const tbEvents = Object.values(tbInfo.events);
	
			if (tbFields.length > 0) {
				output.push("");
	
				for (const fieldDef of tbFields) {
					output.push(`${fieldDef};`);
				}
			}
	
			if (tbIndexes.length > 0) {
				output.push("");
	
				for (const indexDef of tbIndexes) {
					output.push(`${indexDef};`);
				}
			}
	
			if (tbEvents.length > 0) {
				output.push("");
	
				for (const eventDef of tbEvents) {
					output.push(`${eventDef};`);
				}
			}
		}
	}

	// Include table data
	if (types.includes('data')) {
		pushSection("TRANSACTION");

		output.push("BEGIN TRANSACTION;");

		for (const [tableName] of dbTables) {
			pushSection(`TABLE DATA: ${tableName}`);
	
			const tbData = await surreal.query(`SELECT * FROM ${tableName}`);
			const tbRows = tbData[0].result as any[];

			if (tbRows.length > 0) {
				const [edges, records] = fork(tbRows, (row) => row.in && row.out);
				
				for (const entry of records) {
					output.push(`UPDATE ${entry.id} CONTENT ${JSON.stringify(entry)};`);
				}

				for (const row of edges) {
					output.push(`RELATE ${row.in} -> ${row.id} -> ${row.out} CONTENT ${JSON.stringify(row)};`);
				}
			}
		}

		pushSection("TRANSACTION");

		output.push("COMMIT TRANSACTION;");
	}

	return output.join("\n");
}

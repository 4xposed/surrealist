@precedence {
	ident,
	FunctionJs,
	Int,
	RecordId,
	Ident,
	Object,
	Number,
	ObjectContent,
	NestableExpressions @left
}

@top SurrealQL { Expressions }
@top SingleExpression { Expression }
@top PermissionsContent { none | full | WhereClause }
@top QlValue { Value }

Expressions {
	(Expression ";")* Expression ";"?
}

NestableExpressions {
	(NestableExpression ";")* NestableExpression ";"?
}

Expression {
	Statement |
	Value
}

NestableExpression {
	NestableStatement |
	Value
}

SubQuery {
	"("
	NestableExpression
	")"
}

Block {
	"{"
	NestableExpressions ~ident
	"}"
}

TransactionStatement {
	BeginStatement |
	CancelStatement |
	CommitStatement
}

NestableStatement {
	CreateStatement |
	SelectStatement |
	BreakStatement |
	ContinueStatement |
	ForStatement |
	ReturnStatement
}

Statement {
	TransactionStatement |
	DefineStatement |
	NestableStatement
}

// Transaction statements

BeginStatement { begin transaction? }
CancelStatement { cancel transaction? }
CommitStatement { commit transaction? }

// Define statements

DefineStatement {
	define
	(
		DefineAnalyzerStatement |
		DefineNamespaceStatement |
		DefineDatabaseStatement |
		DefineEventStatement |
		DefineFieldStatement |
		DefineFunctionStatement |
		DefineIndexStatement
	)
}

// TODO implement filters
DefineAnalyzerStatement { analyzer Ident TokenizersClause? CommentClause? }
DefineEventStatement { event Ident OnTableClause WhenThenClause CommentClause? }
DefineNamespaceStatement { namespace Ident CommentClause? }
DefineDatabaseStatement { database Ident on Ident CommentClause? }

DefineFieldStatement {
	field
	IfNotExistsClause?
	Ident
	OnTableClause
	(
		TypeClause |
		DefaultClause |
		ReadonlyClause |
		ValueClause |
		AssertClause |
		PermissionsForClause |
		CommentClause
	)*
}

DefineFunctionStatement {
	function
	IfNotExistsClause?
	customFunctionName
	"("
	(
		VariableName ":" Type
		( "," VariableName ":" Type )*
	)?
	")"
	Block
	(
		PermissionsBasicClause |
		CommentClause
	)*
}

DefineIndexStatement {
	index
	IfNotExistsClause?
	Ident
	OnTableClause
	FieldsColumnsClause
	(
		UniqueClause |
		SearchAnalyzerClause |
		MtreeClause
	)
}

// Data statements

CreateStatement {
	create only?
	( Ident | VariableName | Function )
	( ContentClause | SetClause )?
	ReturnClause?
	TimeoutClause?
	ParallelClause?
}

SelectStatement {
	(select)
	(
		value Predicate |
		commaSep<InclusivePredicate>
	)
	(from)
	(only)?
	(
		NestableStatement |
		(
			commaSep<Value>
			WithClause?
			WhereClause?
			SplitClause?
			GroupClause?
			OrderClause?
			LimitStartComboClause?
			FetchClause?
			TimeoutClause?
			ParallelClause?
			ExplainClause?
		)
	)
}

// Control statements
BreakStatement { break }
ContinueStatement { continue }
ForStatement { for VariableName in ( Array | VariableName | SubQuery | Block ) Block }
ReturnStatement { return NestableExpression }

// Values

Value { String | Number | true | false | null | none | VariableName | rawident | Array | RecordId | FunctionJs | Function | SubQuery | Block | Object | TypeCast }

// Objects

ObjectKey[@dynamicPrecedence=2] {
	rawident ~ident |
	singleString ~string |
	doubleString ~string
}

ObjectProperty {
	ObjectKey ":" Value
}

ObjectContent {
	commaSep<ObjectProperty>
}

Object {
	"{" ObjectContent? "}"
}

// Arrays

Array { "[" commaSep<Value>? "]"}

// Record Ids

RecordIdIdent[@dynamicPrecedence=1] {
  rawident ~ident |
  Ident ~ident |
  bracketIdent
}

RecordId {
	RecordIdIdent
	":"
	(
		RecordIdIdent |
		Number |
		Array |
		Object
	)
}

// JS Functions

FunctionJs {
	"function"
	"(" commaSep<Value>? ")"
	"{" JavaScript? "}"
}

// Function invocation

Function {
	functionName
	"(" commaSep<Value>? ")"
}

// Assignment

FieldAssignment {
	Ident
	"="
	Value
}

// Clauses

OnTableClause {
	on table? Ident
}

FieldsColumnsClause {
	( fields | columns ) commaSep<Ident>
}

UniqueClause {
	unique
}

SearchAnalyzerClause {
	search analyzer
	Ident
	Bm25Clause?
	DocIdsOrderClause?
	DocLenghtsOrderClause?
	PostingsOrderClause?
	TermsOrderClause?
	DocIdsCacheClause?
	DocLenghtsCacheClause?
	PostingsCacheClause?
	TermsCacheClause?
	highlights?
}

Bm25Clause { bm25 ( "(" Float "," Float ")")? }
DocIdsCacheClause { doc_ids_cache Int }
DocIdsOrderClause { doc_ids_order Int }
DocLenghtsCacheClause { doc_lengths_cache Int }
DocLenghtsOrderClause { doc_lengths_order Int }
PostingsCacheClause { postings_cache Int }
PostingsOrderClause { postings_order Int }
TermsCacheClause { terms_cache Int }
TermsOrderClause { terms_order Int}

MtreeClause {
	mtree
	MtreeDimensionClause?
	MtreeDistClause?
	MtreeTypeClause?
	MtreeCapacityClause?
	DocIdsOrderClause?
	DocIdsCacheClause?
	MtreeCacheClause?
}

MtreeDimensionClause { dimension Int }
MtreeDistClause { dist ( euclidean | cosine | manhattan | minkowski ) }
MtreeTypeClause { type ( f32 | f64 | i16 | i32 | i64 ) }
MtreeCapacityClause { capacity Int }
MtreeCacheClause { mtree_cache Int }

ContentClause {
	content Object
}

SetClause {
	set commaSep<FieldAssignment>
}

IfNotExistsClause {
	if not exists
}

ReturnClause {
	// TODO add support for projections
	return
	( none | before | after | diff )
}

TimeoutClause {
	timeout
	// TODO actual timeout
}

ParallelClause {
	parallel
}

FetchClause {
	fetch
	commaSep<Ident>
}

StartClause {
	start
	at?
	(Int | VariableName)
}

LimitClause {
	limit
	by?
	(Int | VariableName)
}

LimitStartComboClause {
	StartClause LimitClause? |
	LimitClause StartClause?
}

GroupClause {
	group
	by?
	commaSep<Ident>
}

OrderClause {
	order
	by?
	commaSep<Ident>
	( asc | desc )?
}

SplitClause {
	split
	at?
	Ident
}

WhereClause {
	where
	Value
}

WithClause {
	with
	(
		noindex |
		index commaSep<Ident>
	)
}

ExplainClause {
	explain
	full?
}

TokenizersClause { tokenizers commaSep<AnalyzerTokenizers> }

WhenThenClause {
	(
		when
		(SubQuery | Block)
	)?
	then?
	(SubQuery | Block)
}

TypeClause {
	flexible?
	type
	// TODO proper types
	Ident
}

ReadonlyClause {
	readonly
}

DefaultClause {
	default
	Value
}

ValueClause {
	value
	Value
}

AssertClause {
	assert
	Value
}

PermissionsForClause {
	permissions
	(
		// TODO make case insensitive but not a keyword
		none | full |
		(
			for
			// TODO make case insensitive but not a keyword
			("select" | "create" | "update" | "delete")
			WhereClause
		)+
	)
}

PermissionsBasicClause {
	permissions
	none | full | WhereClause
}

CommentClause {
	comment
	String
}

// Support

AnalyzerTokenizers {
	"blank" |
	"camel" |
	"class" |
	"punct"
}

Predicate {
	Value |
	Value as Ident
}

InclusivePredicate {
	"*" |
	Predicate
}

// Idiom {
// 	Ident
// 	("." Ident)*
// }

// Types

Type {
	StringType |
	NumberType |
	AnyType |
	BoolType |
	BytesType |
	DatetimeType |
	DecimalType |
	DurationType |
	FloatType |
	IntType |
	NullType |
	ObjectType |
	ArrayType |
	SetType |
	RecordType |
	OptionType |
	GeometryType
}

TypeBracketOpen { "<" }
TypeBracketClose { ">" }

StringType[@name="Type"] { "string" }
NumberType[@name="Type"] { "number" }
AnyType[@name="Type"] { "any" }
BoolType[@name="Type"] { "bool" }
BytesType[@name="Type"] { "bytes" }
DatetimeType[@name="Type"] { "datetime" }
DecimalType[@name="Type"] { "decimal" }
DurationType[@name="Type"] { "duration" }
FloatType[@name="Type"] { "float" }
IntType[@name="Type"] { "int" }
NullType[@name="Type"] { "null" }
ObjectType[@name="Type"] { "object" }
ArrayType[@name="Type"] { "array" ( TypeBracketOpen Type TypeBracketClose )? }
SetType[@name="Type"] { "set" ( TypeBracketOpen Type TypeBracketClose )? }
RecordType[@name="Type"] { "record" ( TypeBracketOpen ( rawident | Int ) TypeBracketClose )? }
OptionType[@name="Type"] { "option" ( TypeBracketOpen Type TypeBracketClose ) }
GeometryType[@name="Type"] {
	"geometry"
	(
		TypeBracketOpen
		( "feature" | "point" | "line" | "polygon" | "multipoint" | "multiline" | "multipolygon" | "collection" )
		TypeBracketClose
	)?
}

TypeCast {
	TypeBracketOpen Type TypeBracketClose Value
}

// Strings
String { singleString ~string | doubleString ~string }

@tokens {
	// Characters
	"{"[@name=BraceOpen]
	"}"[@name=BraceClose]
	"["
	"]"
	":"[@name=Colon]

	// Helpers
	whitespace { $[ \n\r\t] }

	// Comments
	Comment { CommentHash | CommentDash | CommentSlash }
	CommentHash { "#" ![\n]* }
	CommentDash { "--" ![\n]* }
	CommentSlash { "//" ![\n]* }

	// Numbers
	Number { Int | Float | Decimal }
	frac { '.' @digit+ }
	exp { $[eE] $[+\-]? @digit+ }
	Int { @digit+ }
	Float { @digit+ frac? exp? "f"? }
	Decimal { @digit+ frac? exp? "dec"? }

	singleString { "'" ![']+ "'" }
	doubleString { '"' !["]+ '"' }

	// Language
	VariableName { "$" (@asciiLetter | @digit | "_" )+ }
	Ident {
		rawident |
		"`" ![`]+ '`'
	}
	bracketIdent {
		"⟨" ![⟩]+ "⟩"
	}
	rawident {
		(@asciiLetter | "_") (@asciiLetter | @digit | "_")+ |
		@digit+ (@asciiLetter | "_") (@asciiLetter | @digit | "_")+
	}

	// Functions
	JavaScript { ![\\\n}]+ }
	functionName[@name=function] {
		"rand" | "RAND" |
		"count" | "COUNT" |
		@asciiLetter+ functionNameSegment+
	}

	functionNameSegment { "::" @asciiLetter+ }
	customFunctionName[@name=function] {
		"fn" functionNameSegment*
	}

	@precedence { "function" JavaScript whitespace Comment customFunctionName functionName Number Int rawident Ident String singleString doubleString }

	"function"
}

commaSep<content> {
	content ("," content)*
}

@skip { whitespace | Comment }
@detectDelim

@external propSource surqlHighlighting from "./highlight"

@external extend { rawident } tokens from "./tokens" {
	analyzer			[@name=Keyword],
	as					[@name=Keyword],
	asc					[@name=Keyword],
	assert				[@name=Keyword],
	at					[@name=Keyword],
	begin				[@name=Keyword],
	bm25				[@name=Keyword],
	break				[@name=Keyword],
	by					[@name=Keyword],
	cancel				[@name=Keyword],
	capacity			[@name=Keyword],
	columns				[@name=Keyword],
	comment				[@name=Keyword],
	commit				[@name=Keyword],
	content				[@name=Keyword],
	continue			[@name=Keyword],
	create				[@name=Keyword],
	database			[@name=Keyword],
	default				[@name=Keyword],
	define				[@name=Keyword],
	desc				[@name=Keyword],
	dimension			[@name=Keyword],
	dist				[@name=Keyword],
	doc_ids_cache		[@name=Keyword],
	doc_ids_order		[@name=Keyword],
	doc_lengths_cache	[@name=Keyword],
	doc_lengths_order	[@name=Keyword],
	exists				[@name=Keyword],
	explain				[@name=Keyword],
	event				[@name=Keyword],
	fetch				[@name=Keyword],
	field				[@name=Keyword],
	fields				[@name=Keyword],
	flexible			[@name=Keyword],
	for					[@name=Keyword],
	from				[@name=Keyword],
	function			[@name=Keyword],
	group				[@name=Keyword],
	highlights			[@name=Keyword],
	if					[@name=Keyword],
	in					[@name=Keyword],
	index				[@name=Keyword],
	limit				[@name=Keyword],
	mtree				[@name=Keyword],
	mtree_cache			[@name=Keyword],
	namespace			[@name=Keyword],
	noindex				[@name=Keyword],
	not					[@name=Keyword],
	on					[@name=Keyword],
	only				[@name=Keyword],
	order				[@name=Keyword],
	parallel			[@name=Keyword],
	permissions			[@name=Keyword],
	postings_cache		[@name=Keyword],
	postings_order		[@name=Keyword],
	readonly			[@name=Keyword],
	return				[@name=Keyword],
	search				[@name=Keyword],
	select				[@name=Keyword],
	set					[@name=Keyword],
	split				[@name=Keyword],
	start				[@name=Keyword],
	table				[@name=Keyword],
	terms_cache			[@name=Keyword],
	terms_order			[@name=Keyword],
	then				[@name=Keyword],
	timeout				[@name=Keyword],
	tokenizers			[@name=Keyword],
	transaction			[@name=Keyword],
	type				[@name=Keyword],
	unique				[@name=Keyword],
	value				[@name=Keyword],
	when				[@name=Keyword],
	where				[@name=Keyword],
	with				[@name=Keyword],

	// Literals
	after				[@name=Literal],
	before				[@name=Literal],
	diff				[@name=Literal],
	false				[@name=Literal],
	full				[@name=Literal],
	none				[@name=Literal],
	null				[@name=Literal],
	true				[@name=Literal],

	f32					[@name=Literal],
	f64					[@name=Literal],
	i16					[@name=Literal],
	i32					[@name=Literal],
	i64					[@name=Literal],

	euclidean			[@name=Literal],
	cosine				[@name=Literal],
	manhattan			[@name=Literal],
	minkowski			[@name=Literal]

}
